import ilog.concert.IloException;

import java.io.IOException;
import java.util.ArrayList;

import CallBacks.MyIncumbentCallBack;
import CallBacks.PricingIncumbentCallBack;
import HelperClasses.ServicesDriver;
import Model.CGMasterModel;
import Model.CGPricingModel;
import Model.Configuration;
import Model.ILPModelModified;
import NFV.Service;
import Network.Network;
import Test.PricingTest;

/**
 * This class is designed to run the column generation algorithm with/without diversification'
 * It differs from the columnGeneration class as it runs the master at each run of the pricing and continiously updated the duals values
 * @author umroot
 *
 */
public class CGRun {

	private Network network;
	private ArrayList<Service> services;
	
	public CGRun (Network network, ArrayList<Service> services)
	{
		this.network = network;
		this.services = services;
	
	}
	
	/**
	 * This function executes the column generation by mapping and scheduling the services
	 * Getting an upper bound on DELTA based on the completion time of the last service
	 * Executing column generation and reporting the results
	 * 
	 * @param pricingFilePath = "pricingResults/pRes_";//"pricingResults/pRes_"+this.service.getId()+"_"+iterations+".txt";
	 * @param masterFilePath = "masterResults/mRes_";// "masterResults/mRes_"+iterations+".txt";
	 * @param ilpFilePath ="masterResults/ILP.txt";
	 * @param startSchedule timeslot at which i want the service schedule to begin
	 * @param DELTA timeline
	 * 
	 * @return Array<int []> int [0]=execution time, int[1] objective value, first array for LP and the second for ILP, third array int [0]=iterations, int[1] =Delta 
	 * it will return null if column generation was not executed due to having a service which caused a mapping exception
	 * @throws IloException
	 * @throws IOException
	 */
	public ArrayList<double[]> executeColumnGeneration( String masterFilePath,String ilpFilePath, String PricingFilePath, int startSchedule, int DELTA) throws IloException, IOException
	{
		
		Configuration c;
		double reducedCost = 0;
		int iterations=1;//at least we will perform one iteration
		int initialColumnsSet = 1; //number of columns per service generated by the heuristic as basic solution for the master
		int pricingwithNegativeRC =0;
		
		//runtime variables
		double startlp =0;
		double endlp =0;
		double startIlp =0;
		double endIlp =0;
		
		//report test results
		ArrayList<double[]> testResults = new ArrayList<double[]>();
		double [] results = new double[2];
	
		int[][]v ;
		int[][][][] o;
		int[][][][] r;
		ArrayList <Configuration> configurations = new ArrayList<Configuration>();	
		ArrayList <int[][][][]> modelInput ;
		SchedulingHeuristic sh = new SchedulingHeuristic(this.network,"logs/ServicesHeuristic.txt");
	
		
		//map and schedule the services
		configurations = sh.mapScheduleService(this.services, DELTA,0);
					
		//check if any of the services was not scheduled, mapped or routed, then return null and do not execute columns generation
		if (configurations == null)
		{
			return null;
		}
		
		//update delta to its upper bound which is the completion time of the last service
		DELTA = startSchedule+this.services.get(this.services.size()-1).getCompletionTime(); 	

		//prepare the initial configurations for the master
		modelInput = sh.convertConfigurations(configurations, DELTA,initialColumnsSet);		
		v = modelInput.get(0)[0][0];
		o = modelInput.get(1);//lsdeltac
		r = modelInput.get(2);//fsdeltac
		
		//build the master model	
		CGMasterModel masterModel = new CGMasterModel(initialColumnsSet,this.services.size(),DELTA, this.network.getLinkList().length,this.network.getVNFNb(), v, r, o,this.network.getLinksCapacities());		
		masterModel.buildMaster();
	
		startlp = System.currentTimeMillis();
		while (true)
		{
			for (int i = 0; i<services.size(); i++)
			{				
				masterModel.runMasterModel(masterFilePath+"_"+services.get(i).getId()+"_"+iterations+".txt",iterations );
				
				CGPricingModel pricingModel = new CGPricingModel(services.get(i), this.network, masterModel, DELTA, startSchedule);
				pricingModel.buildPricingModel(null);
				
				c = pricingModel.runPricingModel(PricingFilePath+"_"+services.get(i).getId()+"_"+iterations+".txt", iterations);
				
				//get the reduced cost of the pricing 
				reducedCost = pricingModel.cplex.getObjValue();		
										
				//compare to a very small value and not 0 since the reduced cost is double and may have value 0.0000 which will not be considered <=0
				if (reducedCost <=1e-10)
				{
					//if reduced cost<=0, no need to add column for this service
					//count the number of pricing having RC<=0, pricing for all services at the same iteration <=0 stop the CG
					pricingwithNegativeRC++;
					
					//this just to mention that no column was added to the service at this iteration so we can read easily the chosen column (if lambda[0][1] = 1; then pRes_0_1 column was chosen) 
					masterModel.cut[services.get(i).getId()].add(null);
				}
				else if (!masterModel.columnExists(c))
				{
					masterModel.addColumnToMaster(c);
				}
				pricingModel.cplex.end();	
			}			
			
			//optimal solution is reached
			if (pricingwithNegativeRC == services.size())
			{
				break;
			}
		
			pricingwithNegativeRC=0;
			iterations++;
		
		}		
		
		
		endlp = System.currentTimeMillis();
		results[0] = endlp - startlp;
		results[1] = masterModel.lpObjectiveValue;
		testResults.add(results);
		
		//run ILP and add results to the array	
		startIlp = System.currentTimeMillis();
		masterModel.runILPMasterModel(ilpFilePath);
		endIlp = System.currentTimeMillis();
		
		results = new double[2];
		results[0] = endIlp - startIlp;
		results[1] = masterModel.IlpObjectiveValue;
		testResults.add(results);
		
		results = new double[2];
		results[0] = iterations;
		results[1] = DELTA;
		testResults.add(results);
		
		return testResults;
	}
	
	
	
	
	/**
	 * This function executes the column generation by mapping and scheduling the services
	 * Getting an upper bound on DELTA based on the completion time of the last service
	 * Executing column generation and reporting the results
	 * 
	 * 
	 * @param pricingFilePath = "pricingResults/pRes_";//"pricingResults/pRes_"+this.service.getId()+"_"+iterations+".txt";
	 * @param masterFilePath = "masterResults/mRes_";// "masterResults/mRes_"+iterations+".txt";
	 * @param ilpFilePath ="masterResults/ILP.txt";
	 * @param startSchedule timeslot at which i want the service schedule to begin
	 * @param DELTA timeline
	 * 
	 * @return Array<int []> int [0]=execution time, int[1] objective value, first array for LP and the second for ILP, third array int [0]=iterations, int[1] =Delta 
	 * it will return null if column generation was not executed due to having a service which caused a mapping exception
	 * @throws IloException
	 * @throws IOException
	 */
	public ArrayList<double[]> executeColumnGenerationDiversification( String masterFilePath,String ilpFilePath, String PricingFilePath, int startSchedule, int DELTA) throws IloException, IOException
	{
	  	PricingIncumbentCallBack incumbentCallback ;
		Configuration c;
		double reducedCost = 0;
		int iterations=1;//at least we will perform one iteration
		int initialColumnsSet = 1; //number of columns per service generated by the heuristic as basic solution for the master
		int pricingwithNegativeRC =0;
		
		//runtime variables
		double startlp =0;
		double endlp =0;
		double startIlp =0;
		double endIlp =0;
		
		//report test results
		ArrayList<double[]> testResults = new ArrayList<double[]>();
		double [] results = new double[2];
	
		int[][]v ;
		int[][][][] o;
		int[][][][] r;
		ArrayList <Configuration> configurations = new ArrayList<Configuration>();	
		ArrayList <int[][][][]> modelInput ;
		SchedulingHeuristic sh = new SchedulingHeuristic(this.network,"logs/ServicesHeuristic.txt");
	
		
		//map and schedule the services
		configurations = sh.mapScheduleService(this.services, DELTA,0);
					
		//check if any of the services was not scheduled, mapped or routed, then return null and do not execute columns generation
		if (configurations == null)
		{
			return null;
		}
		
		//update delta to its upper bound which is the completion time of the last service
		DELTA = startSchedule+this.services.get(this.services.size()-1).getCompletionTime(); 	

		//prepare the initial configurations for the master
		modelInput = sh.convertConfigurations(configurations, DELTA,initialColumnsSet);		
		v = modelInput.get(0)[0][0];
		o = modelInput.get(1);//lsdeltac
		r = modelInput.get(2);//fsdeltac
		
		//build the master model	
		CGMasterModel masterModel = new CGMasterModel(initialColumnsSet,this.services.size(),DELTA, this.network.getLinkList().length,this.network.getVNFNb(), v, r, o,this.network.getLinksCapacities());		
		masterModel.buildMaster();
	
		startlp = System.currentTimeMillis();
		while (true)
		{
			for (int i = 0; i<services.size(); i++)
			{	
				
				//run master at each iteration so that the dual will be constantly updated making the next service aware of the configuration of the previous one by the updated dual
				masterModel.runMasterModel(masterFilePath+"_"+services.get(i).getId()+"_"+iterations+".txt",iterations );
				
				CGPricingModel pricingModel = new CGPricingModel(services.get(i), this.network, masterModel, DELTA, startSchedule);
				pricingModel.buildPricingModel(null);
				
				//store the incumbent solutions by using the callback
				incumbentCallback = new PricingIncumbentCallBack(pricingModel, masterModel);
			  	pricingModel.cplex.use(incumbentCallback);
			  	
			  	c = pricingModel.runPricingModel(PricingFilePath+"_"+services.get(i).getId()+"_"+iterations+".txt", iterations);
			  	
				//get the reduced cost of the pricing 
				reducedCost = pricingModel.cplex.getObjValue();		
				
				pricingModel.cplex.clearCallbacks();
				
										
				//compare to a very small value and not 0 since the reduced cost is double and may have value 0.0000 which will not be considered <=0
				if (reducedCost <=1e-10)
				{
					//if reduced cost<=0, no need to add column for this service
					//count the number of pricing having RC<=0, pricing for all services at the same iteration <=0 stop the CG
					pricingwithNegativeRC++;
					
					//this just to mention that no column was added to the service at this iteration so we can read easily the chosen column (if lambda[0][1] = 1; then pRes_0_1 column was chosen) 
					masterModel.cut[services.get(i).getId()].add(null);
				}
				else if (!masterModel.columnExists(c))
				{
					masterModel.addColumnToMaster(c);
				}
				pricingModel.cplex.end();	
			}			
			
			//optimal solution is reached
			if (pricingwithNegativeRC == services.size())
			{
				break;
			}
		
			pricingwithNegativeRC=0;
			iterations++;
		
		}		
		
		
		endlp = System.currentTimeMillis();
		results[0] = endlp - startlp;
		results[1] = masterModel.lpObjectiveValue;
		testResults.add(results);
		
		//add all incumbent solutions before running ILP; this will only add configurations that do not already exist in the maste
		//masterModel.addIncumbentColumns();
		
		//run ILP and add results to the array	
		startIlp = System.currentTimeMillis();
		masterModel.runILPMasterModel(ilpFilePath);
		endIlp = System.currentTimeMillis();
		
		results = new double[2];
		results[0] = endIlp - startIlp;
		results[1] = masterModel.IlpObjectiveValue;
		testResults.add(results);
		
		results = new double[2];
		results[0] = iterations;
		results[1] = DELTA;
		testResults.add(results);
		
		return testResults;
	}
	
	public static void main(String[]args) throws IloException, IOException
	{	
		String pricingFilePath = "testResults/pricingResults/pRes_";//"pricingResults/pRes_"+this.service.getId()+"_"+iterations+".txt";
		String masterFilePath = "testResults/masterResults/mRes_";// "masterResults/mRes_"+iterations+".txt";
		String ilpFilePath ="testResults/masterResults/ILP.txt";
		ArrayList<double[]> CGResults = new ArrayList<double[]>();
		ArrayList<double[]> CGDiverResults = new ArrayList<double[]>();
		int delta =500;	//100
		
		//Create the network
		int vnfTypesNb= 7;//7,10;// should be equal to VNF number when used to map a service
		//Network  graph = new Network(vnfTypesNb,vnfTypesNb,4,5,200,200,1);
		//Network  graph = new Network(5,5,3,3,200,200,1);
		Network  graph = new Network(vnfTypesNb,vnfTypesNb,4,5,500,500,1,0);//the problem
		ArrayList<int[][]> physicalNetwork = graph.buildPhysicalNetwork();			 
		
		 //get the types of VNFs in the network
		int[] tf = physicalNetwork.get(2)[0];	
		
		 //generate services
		ServicesDriver driver = new ServicesDriver (4,  delta, 3, 5, 200, 500, 5 , 1, 500, 1500,tf);//the problem
		//ServicesDriver driver = new ServicesDriver (4,  delta, 3, 4, 50, 100, 4 , 1, 100, 200,tf);
		//ServicesDriver driver = new ServicesDriver (15, delta, 3, 7, 50, 100, 6 , 1, 100, 200,tf);
		ArrayList<int[][]>  services = driver.generateServicesForModel();
		ArrayList<Service> servicesObjects = driver.convertGeneratedServices(services);
		
	
		//start column generation
		CGRun CG = new CGRun(graph, servicesObjects);		
		
		CGResults = CG.executeColumnGeneration(masterFilePath, ilpFilePath, pricingFilePath,0,delta);
		
		CGDiverResults = CG.executeColumnGenerationDiversification(masterFilePath, ilpFilePath, pricingFilePath,0,delta);
		//print results
		if (CGResults == null || CGDiverResults==null)
		{
			System.out.println("Some Services were not scheduled/mapped/routed - Column generation did not execute");
		}
		else
		{
			System.out.println("==============COLUMN GENERATION RESULTS==================");
			System.out.println("COLUMN GENERATION LP RESULTS");
			System.out.println("\t Execution Time: "+CGResults.get(0)[0]);
			System.out.println("\t Objective value: "+CGResults.get(0)[1]);
			
			System.out.println("\nCOLUMN GENERATION ILP RESULTS");
			System.out.println("\t Execution Time: "+CGResults.get(1)[0]);
			System.out.println("\t Objective value: "+CGResults.get(1)[1]);
			
			System.out.println("\nOther Info");
			System.out.println("\t Number of iterations needed to converge: "+CGResults.get(2)[0]);
			System.out.println("\t Timeline Delta: "+CGResults.get(2)[1]);
			
			System.out.println("\n==============COLUMN GENERATION with Diversification RESULTS==================");
			System.out.println("COLUMN GENERATION LP RESULTS");
			System.out.println("\t Execution Time: "+CGDiverResults.get(0)[0]);
			System.out.println("\t Objective value: "+CGDiverResults.get(0)[1]);
			
			System.out.println("\nCOLUMN GENERATION ILP RESULTS");
			System.out.println("\t Execution Time: "+CGDiverResults.get(1)[0]);
			System.out.println("\t Objective value: "+CGDiverResults.get(1)[1]);
			
			System.out.println("\nOther Info");
			System.out.println("\t Number of iterations needed to converge: "+CGDiverResults.get(2)[0]);
			System.out.println("\t Timeline Delta: "+CGDiverResults.get(2)[1]);
		}
		
	}
	
	
}
